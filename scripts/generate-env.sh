#!/usr/bin/env sh
set -eu

# Generates a fresh .env:
# - prompts for FEEDLAND_DOMAIN
# - generates strong random MySQL passwords
# - leaves COMPOSE_PROFILES=caddy commented out (user can enable later)

ENV_FILE=".env"

say() { printf "%s\n" "$*"; }
err() { printf "Error: %s\n" "$*" >&2; }
have() { command -v "$1" >/dev/null 2>&1; }

gen_secret() {
  # env-safe (alphanumeric) to avoid quoting issues in .env
  if have openssl; then
    openssl rand -base64 48 | tr -dc 'A-Za-z0-9' | cut -c1-40
    return
  fi
  if have python3; then
    python3 - <<'PY'
import secrets, string
alphabet = string.ascii_letters + string.digits
print(''.join(secrets.choice(alphabet) for _ in range(40)))
PY
    return
  fi
  err "Need openssl or python3 to generate passwords."
  exit 1
}

prompt_domain() {
  if [ ! -t 0 ]; then
    err "No TTY available for prompting."
    err "Run interactively, or create .env manually from .env.example."
    exit 1
  fi

  say ""
  say "Enter the hostname you will use for FeedLand (example: feed.example.com)"
  printf "FEEDLAND_DOMAIN: "
  read -r FEEDLAND_DOMAIN || true
  FEEDLAND_DOMAIN=$(printf "%s" "$FEEDLAND_DOMAIN" | tr -d '[:space:]')

  if [ -z "${FEEDLAND_DOMAIN:-}" ]; then
    err "FEEDLAND_DOMAIN cannot be empty."
    exit 1
  fi
  if [ "$FEEDLAND_DOMAIN" = "feedland.example.com" ]; then
    err "Please enter a real hostname, not 'feedland.example.com'."
    exit 1
  fi
}

gen_localhost_config() {
  local template_file="templates/localhost.config.template.json"
  local output_file="config.json"
  
  if [ ! -f "$template_file" ]; then
    err "Template file not found: $template_file"
    return 1
  fi
  
  if [ -f "$output_file" ]; then
    err "$output_file already exists. Refusing to overwrite."
    err "Delete it first if you want to regenerate: rm $output_file"
    return 1
  fi
  
  # Read template and replace ${MYSQL_USER_PASSWORD} with actual password
  sed "s|\${MYSQL_USER_PASSWORD}|$user_pw|g" "$template_file" > "$output_file"
  
  say "✅ Wrote $output_file"
}

main() {
  local with_localhost_config=0
  
  # Parse command-line arguments
  for arg in "$@"; do
    case "$arg" in
      --http-localhost)
        with_localhost_config=1
        ;;
      *)
        err "Unknown option: $arg"
        exit 1
        ;;
    esac
  done

  if [ -f "$ENV_FILE" ]; then
    err "$ENV_FILE already exists. Refusing to overwrite."
    err "Delete it first if you want to regenerate: rm .env"
    exit 1
  fi

  if [ $with_localhost_config -eq 1 ]; then
    FEEDLAND_DOMAIN="localhost:1452"
    say ""
    say "✅ Setting FEEDLAND_DOMAIN=localhost:1452 for localhost development"
  else
    prompt_domain
  fi

  root_pw="$(gen_secret)"
  user_pw="$(gen_secret)"

  # Determine COMPOSE_PROFILES comment status
  local compose_profiles_line="#COMPOSE_PROFILES=caddy"
  if [ $with_localhost_config -eq 0 ]; then
    compose_profiles_line="#COMPOSE_PROFILES=caddy"
  fi

  cat > "$ENV_FILE" <<EOF
# Generated by scripts/generate-env.sh
# Required
FEEDLAND_DOMAIN=$FEEDLAND_DOMAIN

# Optional: enable later by uncommenting
$compose_profiles_line

# MySQL credentials (generated)
MYSQL_ROOT_PASSWORD=$root_pw
MYSQL_USER_PASSWORD=$user_pw
EOF

  chmod 600 "$ENV_FILE" 2>/dev/null || true

  say ""
  say "✅ Wrote $ENV_FILE"
  say "To view MySQL passwords later:"
  say "  grep '^MYSQL_\(ROOT_PASSWORD\|USER_PASSWORD\)=' .env"
  say ""
  
  if [ $with_localhost_config -eq 1 ]; then
    say ""
    gen_localhost_config || exit 1
  fi
  
  say ""
  say "Next run:"
  say "  docker compose up -d"
}

main "$@"
